# Экономия памяти, __slots__

# При создании класса можно явно указать перечень имён свойств, которые в нём будут использоваться.

class Triangle:
    __slots__ = ('_a', '_b', '_c')

    def __init__(self, a, b, c):
        self._a = a
        self._b = b
        self._c = c


triangle = Triangle(3, 4, 5)
print(triangle)
# print(triangle.__dict__)  # AttributeError: 'Triangle' object has no attribute '__dict__'.
# __dict__ теперь отсутствует в экземпляре класса, но есть в самом классе
print(Triangle.__dict__)
# {'__module__': '__main__', '__slots__': ('_a', '_b', '_c'),
# '__init__': <function Triangle.__init__ at 0x0000018106385580>,
# '_a': <member '_a' of 'Triangle' objects>,
# '_b': <member '_b' of 'Triangle' objects>,
# '_c': <member '_c' of 'Triangle' objects>,
# '__doc__': None}

"""
# Коротко о том, что даёт замена изменяемого __dict__ на неизменяемый __slots__?

# 1. Обеспечивает немедленное обнаружение ошибок из-за неправильного
# написания атрибутов. Допускаются только имена атрибутов, указанные в __slots__

# 2. Помогает создавать неизменяемые объекты, в которых дескрипторы
# управляют доступом к закрытым атрибутам, хранящимся в __slots__

# 3. Экономит память. В 64-битной сборке Linux экземпляр с двумя атрибутами
# занимает 48 байт со __slots__ и 152 байт без него. Экономия памяти имеет
# значение только тогда, когда будет создано большое количество
# экземпляров.

# 4. Улучшает скорость. По данным на Python 3.10 на процессоре Apple M1 чтение
# переменных экземпляра выполняется на 35% быстрее со __slots__().

# 5. Блокирует такие инструменты как functools.cached_property(), которым для
# правильной работы требуется экземплярный словарь.
"""
